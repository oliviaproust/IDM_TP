/******************************************************************************
 * This file was generated by langium-visitor.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

import * as ASTInterfaces from '../language/generated/ast.js';
import { LangiumCoreServices, ValidationAcceptor, ValidationChecks } from 'langium';

/**
 * This interface is used to define the visitor methods for the B0Tch language.
 */
export interface B0TchVisitor {
    visitDefFonction(node : DefFonction) : any;
    visitInstruction(node : Instruction) : any;
    visitCondition(node : Condition) : any;
    visitExpression(node : Expression) : any;
    visitCallFonction(node : CallFonction) : any;
    visitConstanteBool(node : ConstanteBool) : any;
    visitConstanteNum(node : ConstanteNum) : any;
    visitConstanteStr(node : ConstanteStr) : any;
    visitConsultVariable(node : ConsultVariable) : any;
    visitDistance(node : Distance) : any;
    visitGetDistance(node : GetDistance) : any;
    visitGetTimestamp(node : GetTimestamp) : any;
    visitMovement(node : Movement) : any;
    visitOperationBinaire(node : OperationBinaire) : any;
    visitAdd(node : Add) : any;
    visitAnd(node : And) : any;
    visitDivide(node : Divide) : any;
    visitEqual(node : Equal) : any;
    visitLessThan(node : LessThan) : any;
    visitMinus(node : Minus) : any;
    visitMoreThan(node : MoreThan) : any;
    visitOr(node : Or) : any;
    visitTimes(node : Times) : any;
    visitOperationUnaire(node : OperationUnaire) : any;
    visitInverse(node : Inverse) : any;
    visitNot(node : Not) : any;
    visitSimpleExpression(node : SimpleExpression) : any;
    visitLoop(node : Loop) : any;
    visitReassignVariable(node : ReassignVariable) : any;
    visitRotation(node : Rotation) : any;
    visitSetSpeed(node : SetSpeed) : any;
    visitVariable(node : Variable) : any;
    visitDefVariable(node : DefVariable) : any;
    visitParametre(node : Parametre) : any;
    visitMetrique(node : Metrique) : any;
    visitCentimeter(node : Centimeter) : any;
    visitMeter(node : Meter) : any;
    visitMillimeter(node : Millimeter) : any;
    visitRobot(node : Robot) : any;
    visitType(node : Type) : any;
    visitBoolean(node : Boolean) : any;
    visitVoid(node : Void) : any;
}

/**
 * This abstract class is used to implement a validation visitor for the B0Tch language.
 * It uses the Langium validator service under the hood and exposes its `accept` method through the `validationAccept` property.
 * This `validationAccept` property is reassigned each time the `visitRoot` method is called, so when Langium called the different validation checks.
 */
export abstract class B0TchValidationVisitor {

    protected validationAccept: ValidationAcceptor = () => {};

    visitRoot(node: Robot, accept: ValidationAcceptor) {
        this.validationAccept = accept;
        node.accept(this);
    }
    
    abstract visitDefFonction(node : DefFonction) : any;
    abstract visitInstruction(node : Instruction) : any;
    abstract visitCondition(node : Condition) : any;
    abstract visitExpression(node : Expression) : any;
    abstract visitCallFonction(node : CallFonction) : any;
    abstract visitConstanteBool(node : ConstanteBool) : any;
    abstract visitConstanteNum(node : ConstanteNum) : any;
    abstract visitConstanteStr(node : ConstanteStr) : any;
    abstract visitConsultVariable(node : ConsultVariable) : any;
    abstract visitDistance(node : Distance) : any;
    abstract visitGetDistance(node : GetDistance) : any;
    abstract visitGetTimestamp(node : GetTimestamp) : any;
    abstract visitMovement(node : Movement) : any;
    abstract visitOperationBinaire(node : OperationBinaire) : any;
    abstract visitAdd(node : Add) : any;
    abstract visitAnd(node : And) : any;
    abstract visitDivide(node : Divide) : any;
    abstract visitEqual(node : Equal) : any;
    abstract visitLessThan(node : LessThan) : any;
    abstract visitMinus(node : Minus) : any;
    abstract visitMoreThan(node : MoreThan) : any;
    abstract visitOr(node : Or) : any;
    abstract visitTimes(node : Times) : any;
    abstract visitOperationUnaire(node : OperationUnaire) : any;
    abstract visitInverse(node : Inverse) : any;
    abstract visitNot(node : Not) : any;
    abstract visitSimpleExpression(node : SimpleExpression) : any;
    abstract visitLoop(node : Loop) : any;
    abstract visitReassignVariable(node : ReassignVariable) : any;
    abstract visitRotation(node : Rotation) : any;
    abstract visitSetSpeed(node : SetSpeed) : any;
    abstract visitVariable(node : Variable) : any;
    abstract visitDefVariable(node : DefVariable) : any;
    abstract visitParametre(node : Parametre) : any;
    abstract visitMetrique(node : Metrique) : any;
    abstract visitCentimeter(node : Centimeter) : any;
    abstract visitMeter(node : Meter) : any;
    abstract visitMillimeter(node : Millimeter) : any;
    abstract visitRobot(node : Robot) : any;
    abstract visitType(node : Type) : any;
    abstract visitBoolean(node : Boolean) : any;
    abstract visitVoid(node : Void) : any;
}


/**
 * This function is used to register a validation visitor for the B0Tch language.
 * It will register the `visitRoot` method as a validation check for the Robot type.
 * @param visitor - The visitor to register.
 * @param services - The Langium services.
 */
export function registerVisitorAsValidator<T extends B0TchValidationVisitor>(visitor: T, services: LangiumCoreServices) {
    const registry = services.validation.ValidationRegistry;
    const checks: ValidationChecks<ASTInterfaces.B0TchAstType> = {
        Robot: (node, accept) => {
            visitor.visitRoot(node as Robot, accept);
        }
    };
    registry.register(checks, visitor);
}


/* Each concrete interfaces in the `ast.js` file have an equivalent generated type with the same properties but also with an `accept` method.
 * While the generated accept-weaver allows us to dynamically add the `accept` function to Langium's types, these types allow it to exist statically, so we can take advantage of TypeScript's typing.
 * The references are overrided to use the visitor types instead of the Langium interfaces/types.
 * Nevertheless, the two are strictly equivalent, and conversion from one to the other is made possible thanks to duck-typing.
 */

type Acceptor = {
    accept: (visitor: B0TchVisitor) => any;
}

function isAcceptor(node: unknown): node is Acceptor {
    return typeof (node as any).accept === 'function';
}


export type DefFonction = Acceptor & ASTInterfaces.DefFonction

export function isDefFonction(node: unknown): node is DefFonction {
    return ASTInterfaces.isDefFonction(node) && isAcceptor(node);
}


export type Instruction = Acceptor & ASTInterfaces.Instruction

export function isInstruction(node: unknown): node is Instruction {
    return ASTInterfaces.isInstruction(node) && isAcceptor(node);
}


export type Condition = Acceptor & ASTInterfaces.Condition

export function isCondition(node: unknown): node is Condition {
    return ASTInterfaces.isCondition(node) && isAcceptor(node);
}


export type Expression = Acceptor & ASTInterfaces.Expression

export function isExpression(node: unknown): node is Expression {
    return ASTInterfaces.isExpression(node) && isAcceptor(node);
}


export type CallFonction = Acceptor & ASTInterfaces.CallFonction

export function isCallFonction(node: unknown): node is CallFonction {
    return ASTInterfaces.isCallFonction(node) && isAcceptor(node);
}


export type ConstanteBool = Acceptor & ASTInterfaces.ConstanteBool

export function isConstanteBool(node: unknown): node is ConstanteBool {
    return ASTInterfaces.isConstanteBool(node) && isAcceptor(node);
}


export type ConstanteNum = Acceptor & ASTInterfaces.ConstanteNum

export function isConstanteNum(node: unknown): node is ConstanteNum {
    return ASTInterfaces.isConstanteNum(node) && isAcceptor(node);
}


export type ConstanteStr = Acceptor & ASTInterfaces.ConstanteStr

export function isConstanteStr(node: unknown): node is ConstanteStr {
    return ASTInterfaces.isConstanteStr(node) && isAcceptor(node);
}


export type ConsultVariable = Acceptor & ASTInterfaces.ConsultVariable

export function isConsultVariable(node: unknown): node is ConsultVariable {
    return ASTInterfaces.isConsultVariable(node) && isAcceptor(node);
}


export type Distance = Acceptor & ASTInterfaces.Distance

export function isDistance(node: unknown): node is Distance {
    return ASTInterfaces.isDistance(node) && isAcceptor(node);
}


export type GetDistance = Acceptor & ASTInterfaces.GetDistance

export function isGetDistance(node: unknown): node is GetDistance {
    return ASTInterfaces.isGetDistance(node) && isAcceptor(node);
}


export type GetTimestamp = Acceptor & ASTInterfaces.GetTimestamp

export function isGetTimestamp(node: unknown): node is GetTimestamp {
    return ASTInterfaces.isGetTimestamp(node) && isAcceptor(node);
}


export type Movement = Acceptor & ASTInterfaces.Movement

export function isMovement(node: unknown): node is Movement {
    return ASTInterfaces.isMovement(node) && isAcceptor(node);
}


export type OperationBinaire = Acceptor & ASTInterfaces.OperationBinaire

export function isOperationBinaire(node: unknown): node is OperationBinaire {
    return ASTInterfaces.isOperationBinaire(node) && isAcceptor(node);
}


export type Add = Acceptor & ASTInterfaces.Add

export function isAdd(node: unknown): node is Add {
    return ASTInterfaces.isAdd(node) && isAcceptor(node);
}


export type And = Acceptor & ASTInterfaces.And

export function isAnd(node: unknown): node is And {
    return ASTInterfaces.isAnd(node) && isAcceptor(node);
}


export type Divide = Acceptor & ASTInterfaces.Divide

export function isDivide(node: unknown): node is Divide {
    return ASTInterfaces.isDivide(node) && isAcceptor(node);
}


export type Equal = Acceptor & ASTInterfaces.Equal

export function isEqual(node: unknown): node is Equal {
    return ASTInterfaces.isEqual(node) && isAcceptor(node);
}


export type LessThan = Acceptor & ASTInterfaces.LessThan

export function isLessThan(node: unknown): node is LessThan {
    return ASTInterfaces.isLessThan(node) && isAcceptor(node);
}


export type Minus = Acceptor & ASTInterfaces.Minus

export function isMinus(node: unknown): node is Minus {
    return ASTInterfaces.isMinus(node) && isAcceptor(node);
}


export type MoreThan = Acceptor & ASTInterfaces.MoreThan

export function isMoreThan(node: unknown): node is MoreThan {
    return ASTInterfaces.isMoreThan(node) && isAcceptor(node);
}


export type Or = Acceptor & ASTInterfaces.Or

export function isOr(node: unknown): node is Or {
    return ASTInterfaces.isOr(node) && isAcceptor(node);
}


export type Times = Acceptor & ASTInterfaces.Times

export function isTimes(node: unknown): node is Times {
    return ASTInterfaces.isTimes(node) && isAcceptor(node);
}


export type OperationUnaire = Acceptor & ASTInterfaces.OperationUnaire

export function isOperationUnaire(node: unknown): node is OperationUnaire {
    return ASTInterfaces.isOperationUnaire(node) && isAcceptor(node);
}


export type Inverse = Acceptor & ASTInterfaces.Inverse

export function isInverse(node: unknown): node is Inverse {
    return ASTInterfaces.isInverse(node) && isAcceptor(node);
}


export type Not = Acceptor & ASTInterfaces.Not

export function isNot(node: unknown): node is Not {
    return ASTInterfaces.isNot(node) && isAcceptor(node);
}


export type SimpleExpression = Acceptor & ASTInterfaces.SimpleExpression

export function isSimpleExpression(node: unknown): node is SimpleExpression {
    return ASTInterfaces.isSimpleExpression(node) && isAcceptor(node);
}


export type Loop = Acceptor & ASTInterfaces.Loop

export function isLoop(node: unknown): node is Loop {
    return ASTInterfaces.isLoop(node) && isAcceptor(node);
}


export type ReassignVariable = Acceptor & ASTInterfaces.ReassignVariable

export function isReassignVariable(node: unknown): node is ReassignVariable {
    return ASTInterfaces.isReassignVariable(node) && isAcceptor(node);
}


export type Rotation = Acceptor & ASTInterfaces.Rotation

export function isRotation(node: unknown): node is Rotation {
    return ASTInterfaces.isRotation(node) && isAcceptor(node);
}


export type SetSpeed = Acceptor & ASTInterfaces.SetSpeed

export function isSetSpeed(node: unknown): node is SetSpeed {
    return ASTInterfaces.isSetSpeed(node) && isAcceptor(node);
}


export type Variable = Acceptor & ASTInterfaces.Variable

export function isVariable(node: unknown): node is Variable {
    return ASTInterfaces.isVariable(node) && isAcceptor(node);
}


export type DefVariable = Acceptor & ASTInterfaces.DefVariable

export function isDefVariable(node: unknown): node is DefVariable {
    return ASTInterfaces.isDefVariable(node) && isAcceptor(node);
}


export type Parametre = Acceptor & ASTInterfaces.Parametre

export function isParametre(node: unknown): node is Parametre {
    return ASTInterfaces.isParametre(node) && isAcceptor(node);
}


export type Metrique = Acceptor & ASTInterfaces.Metrique

export function isMetrique(node: unknown): node is Metrique {
    return ASTInterfaces.isMetrique(node) && isAcceptor(node);
}


export type Centimeter = Acceptor & ASTInterfaces.Centimeter

export function isCentimeter(node: unknown): node is Centimeter {
    return ASTInterfaces.isCentimeter(node) && isAcceptor(node);
}


export type Meter = Acceptor & ASTInterfaces.Meter

export function isMeter(node: unknown): node is Meter {
    return ASTInterfaces.isMeter(node) && isAcceptor(node);
}


export type Millimeter = Acceptor & ASTInterfaces.Millimeter

export function isMillimeter(node: unknown): node is Millimeter {
    return ASTInterfaces.isMillimeter(node) && isAcceptor(node);
}


export type Robot = Acceptor & ASTInterfaces.Robot

export function isRobot(node: unknown): node is Robot {
    return ASTInterfaces.isRobot(node) && isAcceptor(node);
}


export type Type = Acceptor & ASTInterfaces.Type

export function isType(node: unknown): node is Type {
    return ASTInterfaces.isType(node) && isAcceptor(node);
}


export type Boolean = Acceptor & ASTInterfaces.Boolean

export function isBoolean(node: unknown): node is Boolean {
    return ASTInterfaces.isBoolean(node) && isAcceptor(node);
}


export type Void = Acceptor & ASTInterfaces.Void

export function isVoid(node: unknown): node is Void {
    return ASTInterfaces.isVoid(node) && isAcceptor(node);
}


/*
 * Each union type in the `ast.js` file have an equivalent generated type but using the visitor classes instead of the Langium interfaces/types.
 * This type is used to propose the `accept` method of their generated types.
 */

export type Direction = Direction_Forward | Direction_Backward | Direction_Left | Direction_Right;

export type Direction_Backward = 'Backward';

export type Direction_Forward = 'Forward';

export type Direction_Left = 'Left';

export type Direction_Right = 'Right';

export type EDouble = number;

export type Num = number;

export type SensRotation = SensRotation_Clock | SensRotation_CounterClock;

export type SensRotation_Clock = 'Clock';

export type SensRotation_CounterClock = 'CounterClock';

export type Str = string;
