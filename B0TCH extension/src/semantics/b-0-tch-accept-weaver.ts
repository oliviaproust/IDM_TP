/******************************************************************************
 * This file was generated by langium-visitor.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

import { AstNode, AstUtils, ContextCache, DocumentState, LangiumCoreServices } from 'langium';
import type { B0TchAstType } from '../language/generated/ast.js';
import * as InterfaceAST from '../language/generated/ast.js';
import * as ClassAST from './b-0-tch-visitor.js';
import { B0TchVisitor } from './b-0-tch-visitor.js';
import { DiagnosticSeverity } from 'vscode-languageserver';


type Weaver = {
    [K in keyof B0TchAstType]?: (node: B0TchAstType[K]) => void;
}

/**
 * This class is used to dynamically add an `accept` method to the Langium generated (concrete) types.
 * It is executed when each time a Langium document goes in "IndexedReferences" state, before the validation phase, but use a cache to avoid reweaving the same AST nodes multiple times.
 */
export class B0TchAcceptWeaver {
    
    private readonly checks: Weaver = {
        DefFonction: this.weaveDefFonction,
        Condition: this.weaveCondition,
        CallFonction: this.weaveCallFonction,
        ConstanteBool: this.weaveConstanteBool,
        ConstanteNum: this.weaveConstanteNum,
        ConstanteStr: this.weaveConstanteStr,
        ConsultVariable: this.weaveConsultVariable,
        Distance: this.weaveDistance,
        GetDistance: this.weaveGetDistance,
        GetTimestamp: this.weaveGetTimestamp,
        Movement: this.weaveMovement,
        Add: this.weaveAdd,
        And: this.weaveAnd,
        Divide: this.weaveDivide,
        Equal: this.weaveEqual,
        LessThan: this.weaveLessThan,
        Minus: this.weaveMinus,
        MoreThan: this.weaveMoreThan,
        Or: this.weaveOr,
        Times: this.weaveTimes,
        Inverse: this.weaveInverse,
        Not: this.weaveNot,
        SimpleExpression: this.weaveSimpleExpression,
        Loop: this.weaveLoop,
        ReassignVariable: this.weaveReassignVariable,
        Rotation: this.weaveRotation,
        SetSpeed: this.weaveSetSpeed,
        DefVariable: this.weaveDefVariable,
        Parametre: this.weaveParametre,
        Centimeter: this.weaveCentimeter,
        Meter: this.weaveMeter,
        Millimeter: this.weaveMillimeter,
        Robot: this.weaveRobot,
        Boolean: this.weaveBoolean,
        Void: this.weaveVoid
    };

    private readonly cache: ContextCache<AstNode, string, void>;

    constructor(services: LangiumCoreServices) {
        this.cache = new ContextCache<AstNode, string, void>();
        services.shared.workspace.DocumentBuilder.onDocumentPhase(DocumentState.IndexedReferences, (document) => {
            if(!document.diagnostics || document.diagnostics.filter(d => d.severity === DiagnosticSeverity.Error).length === 0) {
                AstUtils.streamAst(document.parseResult.value).forEach((node: AstNode) => {
                    if(!this.cache.has(node, 'weaved')) {
                        const nodeType = node.$type as keyof Weaver;
                        const weaveFunction = this.checks[nodeType]; 
                        if (weaveFunction) {
                            weaveFunction(node as any);
                            this.cache.set(node, 'weaved', undefined);
                        }
                    }
                });
            }
        });
    }

    
    weaveDefFonction(node : InterfaceAST.DefFonction) : void {
        (<any> node).accept = (visitor: B0TchVisitor) => { return visitor.visitDefFonction(node as unknown as ClassAST.DefFonction); }
    }
    
    weaveCondition(node : InterfaceAST.Condition) : void {
        (<any> node).accept = (visitor: B0TchVisitor) => { return visitor.visitCondition(node as unknown as ClassAST.Condition); }
    }
    
    weaveCallFonction(node : InterfaceAST.CallFonction) : void {
        (<any> node).accept = (visitor: B0TchVisitor) => { return visitor.visitCallFonction(node as unknown as ClassAST.CallFonction); }
    }
    
    weaveConstanteBool(node : InterfaceAST.ConstanteBool) : void {
        (<any> node).accept = (visitor: B0TchVisitor) => { return visitor.visitConstanteBool(node as unknown as ClassAST.ConstanteBool); }
    }
    
    weaveConstanteNum(node : InterfaceAST.ConstanteNum) : void {
        (<any> node).accept = (visitor: B0TchVisitor) => { return visitor.visitConstanteNum(node as unknown as ClassAST.ConstanteNum); }
    }
    
    weaveConstanteStr(node : InterfaceAST.ConstanteStr) : void {
        (<any> node).accept = (visitor: B0TchVisitor) => { return visitor.visitConstanteStr(node as unknown as ClassAST.ConstanteStr); }
    }
    
    weaveConsultVariable(node : InterfaceAST.ConsultVariable) : void {
        (<any> node).accept = (visitor: B0TchVisitor) => { return visitor.visitConsultVariable(node as unknown as ClassAST.ConsultVariable); }
    }
    
    weaveDistance(node : InterfaceAST.Distance) : void {
        (<any> node).accept = (visitor: B0TchVisitor) => { return visitor.visitDistance(node as unknown as ClassAST.Distance); }
    }
    
    weaveGetDistance(node : InterfaceAST.GetDistance) : void {
        (<any> node).accept = (visitor: B0TchVisitor) => { return visitor.visitGetDistance(node as unknown as ClassAST.GetDistance); }
    }
    
    weaveGetTimestamp(node : InterfaceAST.GetTimestamp) : void {
        (<any> node).accept = (visitor: B0TchVisitor) => { return visitor.visitGetTimestamp(node as unknown as ClassAST.GetTimestamp); }
    }
    
    weaveMovement(node : InterfaceAST.Movement) : void {
        (<any> node).accept = (visitor: B0TchVisitor) => { return visitor.visitMovement(node as unknown as ClassAST.Movement); }
    }
    
    weaveAdd(node : InterfaceAST.Add) : void {
        (<any> node).accept = (visitor: B0TchVisitor) => { return visitor.visitAdd(node as unknown as ClassAST.Add); }
    }
    
    weaveAnd(node : InterfaceAST.And) : void {
        (<any> node).accept = (visitor: B0TchVisitor) => { return visitor.visitAnd(node as unknown as ClassAST.And); }
    }
    
    weaveDivide(node : InterfaceAST.Divide) : void {
        (<any> node).accept = (visitor: B0TchVisitor) => { return visitor.visitDivide(node as unknown as ClassAST.Divide); }
    }
    
    weaveEqual(node : InterfaceAST.Equal) : void {
        (<any> node).accept = (visitor: B0TchVisitor) => { return visitor.visitEqual(node as unknown as ClassAST.Equal); }
    }
    
    weaveLessThan(node : InterfaceAST.LessThan) : void {
        (<any> node).accept = (visitor: B0TchVisitor) => { return visitor.visitLessThan(node as unknown as ClassAST.LessThan); }
    }
    
    weaveMinus(node : InterfaceAST.Minus) : void {
        (<any> node).accept = (visitor: B0TchVisitor) => { return visitor.visitMinus(node as unknown as ClassAST.Minus); }
    }
    
    weaveMoreThan(node : InterfaceAST.MoreThan) : void {
        (<any> node).accept = (visitor: B0TchVisitor) => { return visitor.visitMoreThan(node as unknown as ClassAST.MoreThan); }
    }
    
    weaveOr(node : InterfaceAST.Or) : void {
        (<any> node).accept = (visitor: B0TchVisitor) => { return visitor.visitOr(node as unknown as ClassAST.Or); }
    }
    
    weaveTimes(node : InterfaceAST.Times) : void {
        (<any> node).accept = (visitor: B0TchVisitor) => { return visitor.visitTimes(node as unknown as ClassAST.Times); }
    }
    
    weaveInverse(node : InterfaceAST.Inverse) : void {
        (<any> node).accept = (visitor: B0TchVisitor) => { return visitor.visitInverse(node as unknown as ClassAST.Inverse); }
    }
    
    weaveNot(node : InterfaceAST.Not) : void {
        (<any> node).accept = (visitor: B0TchVisitor) => { return visitor.visitNot(node as unknown as ClassAST.Not); }
    }
    
    weaveSimpleExpression(node : InterfaceAST.SimpleExpression) : void {
        (<any> node).accept = (visitor: B0TchVisitor) => { return visitor.visitSimpleExpression(node as unknown as ClassAST.SimpleExpression); }
    }
    
    weaveLoop(node : InterfaceAST.Loop) : void {
        (<any> node).accept = (visitor: B0TchVisitor) => { return visitor.visitLoop(node as unknown as ClassAST.Loop); }
    }
    
    weaveReassignVariable(node : InterfaceAST.ReassignVariable) : void {
        (<any> node).accept = (visitor: B0TchVisitor) => { return visitor.visitReassignVariable(node as unknown as ClassAST.ReassignVariable); }
    }
    
    weaveRotation(node : InterfaceAST.Rotation) : void {
        (<any> node).accept = (visitor: B0TchVisitor) => { return visitor.visitRotation(node as unknown as ClassAST.Rotation); }
    }
    
    weaveSetSpeed(node : InterfaceAST.SetSpeed) : void {
        (<any> node).accept = (visitor: B0TchVisitor) => { return visitor.visitSetSpeed(node as unknown as ClassAST.SetSpeed); }
    }
    
    weaveDefVariable(node : InterfaceAST.DefVariable) : void {
        (<any> node).accept = (visitor: B0TchVisitor) => { return visitor.visitDefVariable(node as unknown as ClassAST.DefVariable); }
    }
    
    weaveParametre(node : InterfaceAST.Parametre) : void {
        (<any> node).accept = (visitor: B0TchVisitor) => { return visitor.visitParametre(node as unknown as ClassAST.Parametre); }
    }
    
    weaveCentimeter(node : InterfaceAST.Centimeter) : void {
        (<any> node).accept = (visitor: B0TchVisitor) => { return visitor.visitCentimeter(node as unknown as ClassAST.Centimeter); }
    }
    
    weaveMeter(node : InterfaceAST.Meter) : void {
        (<any> node).accept = (visitor: B0TchVisitor) => { return visitor.visitMeter(node as unknown as ClassAST.Meter); }
    }
    
    weaveMillimeter(node : InterfaceAST.Millimeter) : void {
        (<any> node).accept = (visitor: B0TchVisitor) => { return visitor.visitMillimeter(node as unknown as ClassAST.Millimeter); }
    }
    
    weaveRobot(node : InterfaceAST.Robot) : void {
        (<any> node).accept = (visitor: B0TchVisitor) => { return visitor.visitRobot(node as unknown as ClassAST.Robot); }
    }
    
    weaveBoolean(node : InterfaceAST.Boolean) : void {
        (<any> node).accept = (visitor: B0TchVisitor) => { return visitor.visitBoolean(node as unknown as ClassAST.Boolean); }
    }
    
    weaveVoid(node : InterfaceAST.Void) : void {
        (<any> node).accept = (visitor: B0TchVisitor) => { return visitor.visitVoid(node as unknown as ClassAST.Void); }
    }
    
}