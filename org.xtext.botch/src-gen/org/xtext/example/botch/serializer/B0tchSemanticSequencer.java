/*
 * generated by Xtext 2.38.0
 */
package org.xtext.example.botch.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.botch.services.B0tchGrammarAccess;
import tP_IDM.Add;
import tP_IDM.And;
import tP_IDM.CallFonction;
import tP_IDM.Centimeter;
import tP_IDM.Condition;
import tP_IDM.Constante;
import tP_IDM.ConsultVariable;
import tP_IDM.DefFonction;
import tP_IDM.DefVariable;
import tP_IDM.Divide;
import tP_IDM.Equal;
import tP_IDM.Inverse;
import tP_IDM.LessThan;
import tP_IDM.Loop;
import tP_IDM.Meter;
import tP_IDM.Millimeter;
import tP_IDM.Minus;
import tP_IDM.MoreThan;
import tP_IDM.Movement;
import tP_IDM.Not;
import tP_IDM.Or;
import tP_IDM.Rotation;
import tP_IDM.SetSpeed;
import tP_IDM.TP_IDMPackage;
import tP_IDM.Times;
import tP_IDM.getTimestamp;

@SuppressWarnings("all")
public class B0tchSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private B0tchGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == TP_IDMPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TP_IDMPackage.ADD:
				sequence_Add(context, (Add) semanticObject); 
				return; 
			case TP_IDMPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case TP_IDMPackage.BOOLEAN:
				sequence_Boolean(context, (tP_IDM.Boolean) semanticObject); 
				return; 
			case TP_IDMPackage.CALL_FONCTION:
				sequence_CallFonction(context, (CallFonction) semanticObject); 
				return; 
			case TP_IDMPackage.CENTIMETER:
				sequence_Centimeter(context, (Centimeter) semanticObject); 
				return; 
			case TP_IDMPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case TP_IDMPackage.CONSTANTE:
				sequence_Constante(context, (Constante) semanticObject); 
				return; 
			case TP_IDMPackage.CONSULT_VARIABLE:
				sequence_ConsultVariable(context, (ConsultVariable) semanticObject); 
				return; 
			case TP_IDMPackage.DEF_FONCTION:
				sequence_DefFonction(context, (DefFonction) semanticObject); 
				return; 
			case TP_IDMPackage.DEF_VARIABLE:
				sequence_DefVariable(context, (DefVariable) semanticObject); 
				return; 
			case TP_IDMPackage.DIVIDE:
				sequence_Divide(context, (Divide) semanticObject); 
				return; 
			case TP_IDMPackage.EQUAL:
				sequence_Equal(context, (Equal) semanticObject); 
				return; 
			case TP_IDMPackage.INVERSE:
				sequence_Inverse(context, (Inverse) semanticObject); 
				return; 
			case TP_IDMPackage.LESS_THAN:
				sequence_LessThan(context, (LessThan) semanticObject); 
				return; 
			case TP_IDMPackage.LOOP:
				sequence_Loop(context, (Loop) semanticObject); 
				return; 
			case TP_IDMPackage.METER:
				sequence_Meter(context, (Meter) semanticObject); 
				return; 
			case TP_IDMPackage.MILLIMETER:
				sequence_Millimeter(context, (Millimeter) semanticObject); 
				return; 
			case TP_IDMPackage.MINUS:
				sequence_Minus(context, (Minus) semanticObject); 
				return; 
			case TP_IDMPackage.MORE_THAN:
				sequence_MoreThan(context, (MoreThan) semanticObject); 
				return; 
			case TP_IDMPackage.MOVEMENT:
				sequence_Movement(context, (Movement) semanticObject); 
				return; 
			case TP_IDMPackage.NOT:
				sequence_Not(context, (Not) semanticObject); 
				return; 
			case TP_IDMPackage.NUMBER:
				sequence_Number(context, (tP_IDM.Number) semanticObject); 
				return; 
			case TP_IDMPackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case TP_IDMPackage.ROTATION:
				sequence_Rotation(context, (Rotation) semanticObject); 
				return; 
			case TP_IDMPackage.SET_SPEED:
				sequence_SetSpeed(context, (SetSpeed) semanticObject); 
				return; 
			case TP_IDMPackage.TIMES:
				sequence_Times(context, (Times) semanticObject); 
				return; 
			case TP_IDMPackage.VOID:
				sequence_Void(context, (tP_IDM.Void) semanticObject); 
				return; 
			case TP_IDMPackage.GET_TIMESTAMP:
				sequence_getTimestamp(context, (getTimestamp) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Add returns Add
	 *     Expression returns Add
	 *     Instruction returns Add
	 *
	 * Constraint:
	 *     (x=Expression y=Expression)
	 * </pre>
	 */
	protected void sequence_Add(ISerializationContext context, Add semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TP_IDMPackage.Literals.OPERATION_BINAIRE__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TP_IDMPackage.Literals.OPERATION_BINAIRE__X));
			if (transientValues.isValueTransient(semanticObject, TP_IDMPackage.Literals.OPERATION_BINAIRE__Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TP_IDMPackage.Literals.OPERATION_BINAIRE__Y));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAddAccess().getXExpressionParserRuleCall_3_0(), semanticObject.getX());
		feeder.accept(grammarAccess.getAddAccess().getYExpressionParserRuleCall_5_0(), semanticObject.getY());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns And
	 *     Instruction returns And
	 *     And returns And
	 *
	 * Constraint:
	 *     (x=Expression y=Expression)
	 * </pre>
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TP_IDMPackage.Literals.OPERATION_BINAIRE__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TP_IDMPackage.Literals.OPERATION_BINAIRE__X));
			if (transientValues.isValueTransient(semanticObject, TP_IDMPackage.Literals.OPERATION_BINAIRE__Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TP_IDMPackage.Literals.OPERATION_BINAIRE__Y));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndAccess().getXExpressionParserRuleCall_3_0(), semanticObject.getX());
		feeder.accept(grammarAccess.getAndAccess().getYExpressionParserRuleCall_5_0(), semanticObject.getY());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Type returns Boolean
	 *     Boolean returns Boolean
	 *
	 * Constraint:
	 *     {Boolean}
	 * </pre>
	 */
	protected void sequence_Boolean(ISerializationContext context, tP_IDM.Boolean semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns CallFonction
	 *     Instruction returns CallFonction
	 *     CallFonction returns CallFonction
	 *
	 * Constraint:
	 *     (libelle=String0? refFonction=[DefFonction|EString])
	 * </pre>
	 */
	protected void sequence_CallFonction(ISerializationContext context, CallFonction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Metrique returns Centimeter
	 *     Centimeter returns Centimeter
	 *
	 * Constraint:
	 *     {Centimeter}
	 * </pre>
	 */
	protected void sequence_Centimeter(ISerializationContext context, Centimeter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns Condition
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     ((bloc+=Instruction bloc+=Instruction*)? condition=Expression)
	 * </pre>
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Constante
	 *     Instruction returns Constante
	 *     Constante returns Constante
	 *
	 * Constraint:
	 *     value=Double?
	 * </pre>
	 */
	protected void sequence_Constante(ISerializationContext context, Constante semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns ConsultVariable
	 *     Instruction returns ConsultVariable
	 *     ConsultVariable returns ConsultVariable
	 *
	 * Constraint:
	 *     defvariable=[DefVariable|EString]
	 * </pre>
	 */
	protected void sequence_ConsultVariable(ISerializationContext context, ConsultVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TP_IDMPackage.Literals.CONSULT_VARIABLE__DEFVARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TP_IDMPackage.Literals.CONSULT_VARIABLE__DEFVARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConsultVariableAccess().getDefvariableDefVariableEStringParserRuleCall_3_0_1(), semanticObject.eGet(TP_IDMPackage.Literals.CONSULT_VARIABLE__DEFVARIABLE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns DefFonction
	 *     DefFonction returns DefFonction
	 *
	 * Constraint:
	 *     (libelle=String0? (bloc+=Instruction bloc+=Instruction*)?)
	 * </pre>
	 */
	protected void sequence_DefFonction(ISerializationContext context, DefFonction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns DefVariable
	 *     DefVariable returns DefVariable
	 *
	 * Constraint:
	 *     (libelle=EString? type=Type valeur=Expression)
	 * </pre>
	 */
	protected void sequence_DefVariable(ISerializationContext context, DefVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Divide
	 *     Instruction returns Divide
	 *     Divide returns Divide
	 *
	 * Constraint:
	 *     (x=Expression y=Expression)
	 * </pre>
	 */
	protected void sequence_Divide(ISerializationContext context, Divide semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TP_IDMPackage.Literals.OPERATION_BINAIRE__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TP_IDMPackage.Literals.OPERATION_BINAIRE__X));
			if (transientValues.isValueTransient(semanticObject, TP_IDMPackage.Literals.OPERATION_BINAIRE__Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TP_IDMPackage.Literals.OPERATION_BINAIRE__Y));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDivideAccess().getXExpressionParserRuleCall_3_0(), semanticObject.getX());
		feeder.accept(grammarAccess.getDivideAccess().getYExpressionParserRuleCall_5_0(), semanticObject.getY());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Equal
	 *     Instruction returns Equal
	 *     Equal returns Equal
	 *
	 * Constraint:
	 *     (x=Expression y=Expression)
	 * </pre>
	 */
	protected void sequence_Equal(ISerializationContext context, Equal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TP_IDMPackage.Literals.OPERATION_BINAIRE__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TP_IDMPackage.Literals.OPERATION_BINAIRE__X));
			if (transientValues.isValueTransient(semanticObject, TP_IDMPackage.Literals.OPERATION_BINAIRE__Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TP_IDMPackage.Literals.OPERATION_BINAIRE__Y));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualAccess().getXExpressionParserRuleCall_3_0(), semanticObject.getX());
		feeder.accept(grammarAccess.getEqualAccess().getYExpressionParserRuleCall_5_0(), semanticObject.getY());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Inverse
	 *     Instruction returns Inverse
	 *     Inverse returns Inverse
	 *
	 * Constraint:
	 *     x=Expression
	 * </pre>
	 */
	protected void sequence_Inverse(ISerializationContext context, Inverse semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TP_IDMPackage.Literals.OPERATION_UNAIRE__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TP_IDMPackage.Literals.OPERATION_UNAIRE__X));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInverseAccess().getXExpressionParserRuleCall_3_0(), semanticObject.getX());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns LessThan
	 *     Instruction returns LessThan
	 *     LessThan returns LessThan
	 *
	 * Constraint:
	 *     (x=Expression y=Expression)
	 * </pre>
	 */
	protected void sequence_LessThan(ISerializationContext context, LessThan semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TP_IDMPackage.Literals.OPERATION_BINAIRE__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TP_IDMPackage.Literals.OPERATION_BINAIRE__X));
			if (transientValues.isValueTransient(semanticObject, TP_IDMPackage.Literals.OPERATION_BINAIRE__Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TP_IDMPackage.Literals.OPERATION_BINAIRE__Y));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLessThanAccess().getXExpressionParserRuleCall_3_0(), semanticObject.getX());
		feeder.accept(grammarAccess.getLessThanAccess().getYExpressionParserRuleCall_5_0(), semanticObject.getY());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns Loop
	 *     Loop returns Loop
	 *
	 * Constraint:
	 *     ((bloc+=Instruction bloc+=Instruction*)? condition=Expression)
	 * </pre>
	 */
	protected void sequence_Loop(ISerializationContext context, Loop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Metrique returns Meter
	 *     Meter returns Meter
	 *
	 * Constraint:
	 *     {Meter}
	 * </pre>
	 */
	protected void sequence_Meter(ISerializationContext context, Meter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Metrique returns Millimeter
	 *     Millimeter returns Millimeter
	 *
	 * Constraint:
	 *     {Millimeter}
	 * </pre>
	 */
	protected void sequence_Millimeter(ISerializationContext context, Millimeter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Minus
	 *     Instruction returns Minus
	 *     Minus returns Minus
	 *
	 * Constraint:
	 *     (x=Expression y=Expression)
	 * </pre>
	 */
	protected void sequence_Minus(ISerializationContext context, Minus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TP_IDMPackage.Literals.OPERATION_BINAIRE__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TP_IDMPackage.Literals.OPERATION_BINAIRE__X));
			if (transientValues.isValueTransient(semanticObject, TP_IDMPackage.Literals.OPERATION_BINAIRE__Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TP_IDMPackage.Literals.OPERATION_BINAIRE__Y));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMinusAccess().getXExpressionParserRuleCall_3_0(), semanticObject.getX());
		feeder.accept(grammarAccess.getMinusAccess().getYExpressionParserRuleCall_5_0(), semanticObject.getY());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns MoreThan
	 *     Instruction returns MoreThan
	 *     MoreThan returns MoreThan
	 *
	 * Constraint:
	 *     (x=Expression y=Expression)
	 * </pre>
	 */
	protected void sequence_MoreThan(ISerializationContext context, MoreThan semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TP_IDMPackage.Literals.OPERATION_BINAIRE__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TP_IDMPackage.Literals.OPERATION_BINAIRE__X));
			if (transientValues.isValueTransient(semanticObject, TP_IDMPackage.Literals.OPERATION_BINAIRE__Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TP_IDMPackage.Literals.OPERATION_BINAIRE__Y));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMoreThanAccess().getXExpressionParserRuleCall_3_0(), semanticObject.getX());
		feeder.accept(grammarAccess.getMoreThanAccess().getYExpressionParserRuleCall_5_0(), semanticObject.getY());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns Movement
	 *     Movement returns Movement
	 *
	 * Constraint:
	 *     (direction=Direction? distance=Double? metrique=Metrique)
	 * </pre>
	 */
	protected void sequence_Movement(ISerializationContext context, Movement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Not
	 *     Instruction returns Not
	 *     Not returns Not
	 *
	 * Constraint:
	 *     x=Expression
	 * </pre>
	 */
	protected void sequence_Not(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TP_IDMPackage.Literals.OPERATION_UNAIRE__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TP_IDMPackage.Literals.OPERATION_UNAIRE__X));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotAccess().getXExpressionParserRuleCall_3_0(), semanticObject.getX());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Type returns Number
	 *     Number returns Number
	 *
	 * Constraint:
	 *     {Number}
	 * </pre>
	 */
	protected void sequence_Number(ISerializationContext context, tP_IDM.Number semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Or
	 *     Instruction returns Or
	 *     Or returns Or
	 *
	 * Constraint:
	 *     (x=Expression y=Expression)
	 * </pre>
	 */
	protected void sequence_Or(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TP_IDMPackage.Literals.OPERATION_BINAIRE__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TP_IDMPackage.Literals.OPERATION_BINAIRE__X));
			if (transientValues.isValueTransient(semanticObject, TP_IDMPackage.Literals.OPERATION_BINAIRE__Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TP_IDMPackage.Literals.OPERATION_BINAIRE__Y));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrAccess().getXExpressionParserRuleCall_3_0(), semanticObject.getX());
		feeder.accept(grammarAccess.getOrAccess().getYExpressionParserRuleCall_5_0(), semanticObject.getY());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns Rotation
	 *     Rotation returns Rotation
	 *
	 * Constraint:
	 *     (sens=SensRotation? degre=Double?)
	 * </pre>
	 */
	protected void sequence_Rotation(ISerializationContext context, Rotation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns SetSpeed
	 *     SetSpeed returns SetSpeed
	 *
	 * Constraint:
	 *     (vitesse=EDouble? metrique=Metrique)
	 * </pre>
	 */
	protected void sequence_SetSpeed(ISerializationContext context, SetSpeed semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Times
	 *     Instruction returns Times
	 *     Times returns Times
	 *
	 * Constraint:
	 *     (x=Expression y=Expression)
	 * </pre>
	 */
	protected void sequence_Times(ISerializationContext context, Times semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TP_IDMPackage.Literals.OPERATION_BINAIRE__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TP_IDMPackage.Literals.OPERATION_BINAIRE__X));
			if (transientValues.isValueTransient(semanticObject, TP_IDMPackage.Literals.OPERATION_BINAIRE__Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TP_IDMPackage.Literals.OPERATION_BINAIRE__Y));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimesAccess().getXExpressionParserRuleCall_3_0(), semanticObject.getX());
		feeder.accept(grammarAccess.getTimesAccess().getYExpressionParserRuleCall_5_0(), semanticObject.getY());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Type returns Void
	 *     Void returns Void
	 *
	 * Constraint:
	 *     {Void}
	 * </pre>
	 */
	protected void sequence_Void(ISerializationContext context, tP_IDM.Void semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instruction returns getTimestamp
	 *     getTimestamp returns getTimestamp
	 *
	 * Constraint:
	 *     {getTimestamp}
	 * </pre>
	 */
	protected void sequence_getTimestamp(ISerializationContext context, getTimestamp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
